<!DOCTYPE html>
<html>
<head>
    <title>DuelSim Web Client</title>
    <style>
        /* CSS Variables for Theming */
        :root {
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --primary-color: #00aaff;
            --secondary-color: #ff4400;
            --border-color: #444;
            --cell-bg: #333;
            --cell-border: #555;
            --player1-color: #0077cc;
            --player2-color: #cc3300;
            --hp-bar-bg: #555;
            --hp-bar-p1: #00aaff;
            --hp-bar-p2: #ff4400;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --font-mono: 'Consolas', 'Courier New', monospace;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            display: flex;
            gap: 30px;
            width: 100%;
            max-width: 1200px;
            justify-content: center;
        }

        .left-panel, .right-panel {
            flex: 1;
            min-width: 300px;
        }

        .arena-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #arena {
            display: grid;
            grid-template-columns: repeat(5, 60px); /* Slightly larger cells */
            grid-template-rows: repeat(5, 60px);
            gap: 3px;
            margin: 20px 0;
            border: 2px solid var(--border-color);
            background-color: #2a2a2a;
            padding: 5px;
            position: relative; /* For positioning effects */
        }

        .cell {
            width: 60px;
            height: 60px;
            background-color: var(--cell-bg);
            border: 1px solid var(--cell-border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
            position: relative; /* Keep for potential future cell effects */
            transition: background-color 0.2s ease;
        }

        .player-icon {
            /* --- Sizing Fix --- */
            width: 50px;  /* Fixed size, slightly smaller than cell */
            height: 50px; /* Fixed size, slightly smaller than cell */
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em; /* Keep text size relative */
            font-weight: bold;
            color: white;
            position: absolute; /* Keep absolute positioning */
            /* --- Transition Fix --- */
            /* Apply transition to left/top for smooth movement */
            transition: transform 0.3s ease-out, box-shadow 0.3s ease, left 0.3s ease-out, top 0.3s ease-out;
            z-index: 10;
            box-sizing: border-box; /* Include padding/border in size */
        }

        .player1-icon { background-color: var(--player1-color); }
        .player2-icon { background-color: var(--player2-color); }

        .player-icon.moving {
             /* Add subtle movement indication if needed */
        }
        .player-icon.attacking {
            animation: attackPulse 0.4s ease-out;
        }
        .player-icon.hit {
            animation: hitShake 0.3s ease-in-out;
        }
         .player-icon.victory {
            animation: victoryPulse 1.5s infinite ease-in-out;
            box-shadow: 0 0 20px gold;
        }


        .player-info {
            background-color: #282828;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
        }
        .player-info h3 { margin-top: 0; }

        .health-bar-container {
            width: 100%; /* Ensure container takes full width */
            height: 20px; /* Give container a fixed height */
            background-color: var(--hp-bar-bg); /* Background for the empty part */
            border-radius: 5px;
            overflow: hidden; /* Hide overflow of the inner bar */
            margin: 8px 0; /* Add some spacing */
            border: 1px solid var(--border-color); /* Optional border */
        }
        .health-bar {
            height: 100%; /* Fill container height */
            width: 0%; /* Start at 0 width, JS will update */
            border-radius: 4px; /* Slightly smaller radius */
            transition: width 0.5s ease-in-out; /* Animate width changes */
            /* Background color is set dynamically via ID */
        }
        #player1-health { background-color: var(--hp-bar-p1); }
        #player2-health { background-color: var(--hp-bar-p2); }

        #status-bar {
            width: 100%;
            max-width: 1200px;
            padding: 10px;
            margin-bottom: 20px;
            text-align: center;
            background-color: #282828;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            font-weight: bold;
        }
        #status-bar.connected { color: lightgreen; }
        #status-bar.disconnected { color: lightcoral; }
        #status-bar.connecting { color: orange; }

        #event-log {
            background-color: #282828;
            padding: 15px;
            border-radius: 8px;
            height: 400px; /* Adjust height as needed */
            overflow-y: auto;
            border: 1px solid var(--border-color);
            font-family: var(--font-mono);
            font-size: 0.9em;
        }
        .event { margin-bottom: 5px; padding: 3px; border-radius: 3px; }
        .event.info { color: #aaa; }
        .event.move { color: #add8e6; } /* Light blue */
        .event.attack { color: #ffcccb; } /* Light red */
        .event.damage { color: #ff8888; font-weight: bold; }
        .event.victory { color: #ffd700; font-weight: bold; background-color: rgba(255, 215, 0, 0.1); }
        .event.error { color: #ff6666; font-weight: bold; }
        .event.end { color: #ffd700; font-weight: bold; }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            transition: background-color 0.2s ease;
        }
        button:hover { background-color: #0088cc; }
        button:disabled { background-color: #555; cursor: not-allowed; }

        /* Damage Number Animation */
        .damage-number {
            position: absolute;
            font-size: 1.2em;
            font-weight: bold;
            color: red;
            pointer-events: none; /* Prevent interaction */
            animation: floatUp 1s ease-out forwards;
            z-index: 20;
        }

        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-40px); opacity: 0; }
        }
        @keyframes attackPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
         @keyframes hitShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-3px); }
        }
        @keyframes victoryPulse {
             0%, 100% { transform: scale(1); box-shadow: 0 0 15px gold; }
             50% { transform: scale(1.05); box-shadow: 0 0 25px gold; }
        }
        @keyframes damageFloat {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-30px); opacity: 0; }
        }

    </style>
</head>
<body>

    <h1>DuelSim Enhanced Client</h1>
    <div id="status-bar" class="disconnected">Disconnected</div>

    <div>
        <button id="connect-btn">Connect</button>
        <button id="disconnect-btn" disabled>Disconnect</button>
        <button id="start-duel-btn">Start Random Duel</button>
    </div>

    <div class="container">
        <div class="left-panel">
            <div id="player1-info" class="player-info">
                <h3>Player 1: <span id="player1-name">-</span></h3>
                <div>HP: <span id="player1-hp">-</span> / <span id="player1-max-hp">-</span></div>
                <div class="health-bar-container">
                    <div id="player1-health" class="health-bar"></div>
                </div>
                <div>Position: <span id="player1-pos">-</span></div>
                <!-- Add Cooldown/Status later if needed -->
            </div>
             <div id="player2-info" class="player-info">
                <h3>Player 2: <span id="player2-name">-</span></h3>
                <div>HP: <span id="player2-hp">-</span> / <span id="player2-max-hp">-</span></div>
                 <div class="health-bar-container">
                    <div id="player2-health" class="health-bar"></div>
                </div>
                <div>Position: <span id="player2-pos">-</span></div>
                 <!-- Add Cooldown/Status later if needed -->
            </div>
        </div>

        <div class="arena-container">
            <div id="arena"></div>
        </div>

        <div class="right-panel">
            <h3>Event Log</h3>
            <div id="event-log"></div>
        </div>
    </div>

    <script>
        // --- Simple Module Pattern for Duel Client ---
        const DuelClient = (() => {
            // --- Configuration ---
            const WS_PORT = 5556;
            const MAX_RECONNECT_ATTEMPTS = 5;
            const RECONNECT_DELAY = 3000; // ms
            const ARENA_SIZE = 5;
            const ARENA_CELL_SIZE = 60; // Match CSS .cell width/height
            const ARENA_GAP = 3;        // Match CSS #arena gap
            const ARENA_PADDING = 5;    // Match CSS #arena padding
            const ICON_SIZE = 50;       // Match CSS .player-icon width/height

            // --- DOM Elements ---
            const elements = {
                statusBar: document.getElementById('status-bar'),
                connectBtn: document.getElementById('connect-btn'),
                disconnectBtn: document.getElementById('disconnect-btn'),
                startDuelBtn: document.getElementById('start-duel-btn'),
                arena: document.getElementById('arena'),
                eventLog: document.getElementById('event-log'),
                p1: {
                    name: document.getElementById('player1-name'),
                    hp: document.getElementById('player1-hp'),
                    maxHp: document.getElementById('player1-max-hp'),
                    healthBar: document.getElementById('player1-health'),
                    pos: document.getElementById('player1-pos'),
                    icon: null // Will be created dynamically
                },
                p2: {
                    name: document.getElementById('player2-name'),
                    hp: document.getElementById('player2-hp'),
                    maxHp: document.getElementById('player2-max-hp'),
                    healthBar: document.getElementById('player2-health'),
                    pos: document.getElementById('player2-pos'),
                    icon: null // Will be created dynamically
                }
            };

            // --- State ---
            let socket = null;
            let battleData = null;
            let reconnectTimer = null;
            let reconnectAttempts = 0;

            // --- Private Methods ---

            function _logEvent(eventData) {
                const div = document.createElement('div');
                let message = '';
                let type = eventData.type || 'info'; // Default type

                if (typeof eventData === 'string') {
                    message = eventData;
                } else if (eventData.message) {
                    message = eventData.message;
                } else {
                    // Format specific event types nicely
                    switch(eventData.type) {
                        case 'move': message = `${eventData.actor} moves to (${eventData.position.join(',')})`; break;
                        case 'attack': message = `${eventData.actor} attacks ${eventData.target}`; break;
                        case 'damage': message = `${eventData.target} takes ${eventData.damage} damage`; type = 'damage'; break; // Assign specific type
                        case 'victory': message = `${eventData.winner} is victorious!`; break;
                        case 'info': message = eventData.message; break;
                        default: message = JSON.stringify(eventData);
                    }
                }

                div.className = `event ${type}`;
                div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                elements.eventLog.appendChild(div);
                elements.eventLog.scrollTop = elements.eventLog.scrollHeight; // Auto-scroll
            }

            function _updateStatus(text, statusClass) {
                elements.statusBar.textContent = text;
                elements.statusBar.className = statusClass; // e.g., 'connected', 'disconnected'
            }

            function _initArena() {
                elements.arena.innerHTML = '';
                for (let y = 0; y < ARENA_SIZE; y++) {
                    for (let x = 0; x < ARENA_SIZE; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.id = `cell-${x}-${y}`;
                        elements.arena.appendChild(cell);
                    }
                }
                 // Clear old icons if any
                if (elements.p1.icon) elements.p1.icon.remove();
                if (elements.p2.icon) elements.p2.icon.remove();
                elements.p1.icon = null;
                elements.p2.icon = null;
            }

            function _updatePlayerUI() {
                if (!battleData || !battleData.players) return;

                const p1 = battleData.players[0];
                const p2 = battleData.players[1];

                // Update Text Info
                elements.p1.name.textContent = p1.name;
                elements.p1.hp.textContent = p1.hp;
                elements.p1.maxHp.textContent = p1.max_hp;
                elements.p1.pos.textContent = `(${p1.position.join(',')})`;

                elements.p2.name.textContent = p2.name;
                elements.p2.hp.textContent = p2.hp;
                elements.p2.maxHp.textContent = p2.max_hp;
                elements.p2.pos.textContent = `(${p2.position.join(',')})`;

                // Update Health Bars
                const p1HealthPercent = Math.max(0, (p1.hp / p1.max_hp) * 100);
                const p2HealthPercent = Math.max(0, (p2.hp / p2.max_hp) * 100);
                elements.p1.healthBar.style.width = `${p1HealthPercent}%`;
                elements.p2.healthBar.style.width = `${p2HealthPercent}%`;

                // Update Arena Icons (positioning)
                _updateArenaIcons(p1, p2);
            }

            function _updateArenaIcons(p1, p2) {
                // Create icons if they don't exist (keep this logic)
                if (!elements.p1.icon) {
                    elements.p1.icon = document.createElement('div');
                    elements.p1.icon.className = 'player-icon player1-icon';
                    elements.p1.icon.textContent = 'P1';
                    elements.arena.appendChild(elements.p1.icon);
                }
                 if (!elements.p2.icon) {
                    elements.p2.icon = document.createElement('div');
                    elements.p2.icon.className = 'player-icon player2-icon';
                    elements.p2.icon.textContent = 'P2';
                    elements.arena.appendChild(elements.p2.icon);
                }

                // --- Positioning Logic Fix ---
                // Calculate offset needed to center the icon within a cell
                const cellCenterOffsetX = (ARENA_CELL_SIZE - ICON_SIZE) / 2;
                const cellCenterOffsetY = (ARENA_CELL_SIZE - ICON_SIZE) / 2;

                // Calculate total size of a cell including the gap
                const cellTotalWidth = ARENA_CELL_SIZE + ARENA_GAP;
                const cellTotalHeight = ARENA_CELL_SIZE + ARENA_GAP;

                // Calculate position based on grid index, cell size, gap, padding, and centering offset
                const p1Left = p1.position[0] * cellTotalWidth + cellCenterOffsetX + ARENA_PADDING;
                const p1Top = p1.position[1] * cellTotalHeight + cellCenterOffsetY + ARENA_PADDING;

                const p2Left = p2.position[0] * cellTotalWidth + cellCenterOffsetX + ARENA_PADDING;
                const p2Top = p2.position[1] * cellTotalHeight + cellCenterOffsetY + ARENA_PADDING;

                // Apply the calculated positions
                elements.p1.icon.style.left = `${p1Left}px`;
                elements.p1.icon.style.top = `${p1Top}px`;

                elements.p2.icon.style.left = `${p2Left}px`;
                elements.p2.icon.style.top = `${p2Top}px`;
            }

            // --- Animation & Effects ---
            function _animateAttack(attackerName) {
                 const icon = (battleData.players[0].name === attackerName) ? elements.p1.icon : elements.p2.icon;
                 if (icon) {
                     icon.classList.add('attacking');
                     // Use transform for pulse effect if preferred over box-shadow animation
                     // icon.style.transform = 'scale(1.1)';
                     setTimeout(() => {
                         icon.classList.remove('attacking');
                         // icon.style.transform = 'scale(1)';
                     }, 400); // Match animation duration
                 }
            }

            function _animateHit(targetName, damage) {
                 const icon = (battleData.players[0].name === targetName) ? elements.p1.icon : elements.p2.icon;
                 if (icon) {
                     icon.classList.add('hit');
                     setTimeout(() => icon.classList.remove('hit'), 300); // Match animation duration

                     // Show damage number (adjust positioning slightly)
                     const damageEl = document.createElement('div');
                     damageEl.className = 'damage-number';
                     damageEl.textContent = `-${damage}`;
                     // Position above the center of the icon
                     damageEl.style.left = `${icon.offsetLeft + ICON_SIZE / 2 - 15}px`; // Adjust centering offset as needed
                     damageEl.style.top = `${icon.offsetTop - 20}px`; // Start slightly higher
                     elements.arena.appendChild(damageEl);
                     setTimeout(() => damageEl.remove(), 1000); // Remove after animation
                 }
            }

             function _animateVictory(winnerName) {
                 const icon = (battleData.players[0].name === winnerName) ? elements.p1.icon : elements.p2.icon;
                 if (icon) {
                     icon.classList.add('victory');
                     // The animation loops, remove class on new battle start if needed
                 }
            }


            // --- WebSocket Handlers ---
            function _handleOpen() {
                _updateStatus('Connected', 'connected');
                elements.connectBtn.disabled = true;
                elements.disconnectBtn.disabled = false;
                _logEvent({ type: 'info', message: 'WebSocket connection established.' });
                reconnectAttempts = 0;
            }

            function _handleClose(event) {
                _updateStatus('Disconnected', 'disconnected');
                elements.connectBtn.disabled = false;
                elements.disconnectBtn.disabled = true;
                socket = null;
                _logEvent({ type: 'error', message: `WebSocket closed (Code: ${event.code})` });

                // Attempt reconnection
                if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                    reconnectAttempts++;
                    const delay = RECONNECT_DELAY * Math.min(reconnectAttempts, 3);
                     _logEvent({ type: 'info', message: `Attempting reconnect ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay / 1000}s...` });
                    reconnectTimer = setTimeout(publicMethods.connect, delay);
                } else {
                    _logEvent({ type: 'error', message: 'Max reconnect attempts reached.' });
                }
            }

            function _handleError(error) {
                _updateStatus('Connection Error', 'disconnected');
                 _logEvent({ type: 'error', message: `WebSocket Error: ${error.message || 'Unknown error'}` });
            }

            function _handleMessage(event) {
                if (event.data === 'ping') {
                    socket.send('pong');
                    return;
                }

                try {
                    const message = JSON.parse(event.data);
                    console.log("Received:", message); // Keep for debugging

                    switch (message.type) {
                        case 'battle_info':
                            battleData = message.data;
                            _initArena(); // Reset arena for new battle
                            _updatePlayerUI();
                            _logEvent({ type: 'info', message: `Battle Info: ${battleData.players[0].name} vs ${battleData.players[1].name}` });
                            break;
                        case 'event':
                            const battleEvent = message.data;
                            _logEvent(battleEvent); // Log the raw event first

                            // Update state based on event
                            if (battleEvent.type === 'move') {
                                const player = battleData.players.find(p => p.name === battleEvent.actor);
                                if (player) player.position = battleEvent.position;
                                _updatePlayerUI(); // Update positions visually
                            } else if (battleEvent.type === 'attack') {
                                _animateAttack(battleEvent.actor);
                                // Damage event will handle HP update and hit animation
                            } else if (battleEvent.type === 'damage') {
                                const target = battleData.players.find(p => p.name === battleEvent.target);
                                if (target) target.hp = Math.max(0, target.hp - battleEvent.damage);
                                _animateHit(battleEvent.target, battleEvent.damage);
                                _updatePlayerUI(); // Update HP bars
                            } else if (battleEvent.type === 'victory') {
                                _animateVictory(battleEvent.winner);
                            }
                            break;
                        case 'battle_end':
                             _logEvent({ type: 'end', message: `Battle ended. Winner: ${message.data.winner}` });
                             // Optionally clear battleData or reset UI further
                            break;
                        default:
                            _logEvent({ type: 'info', message: `Unknown message type: ${message.type}` });
                    }
                } catch (e) {
                    _logEvent({ type: 'error', message: `Failed to process message: ${e.message}` });
                    console.error("Message processing error:", e, "Raw data:", event.data);
                }
            }

            // --- Public Methods ---
            const publicMethods = {
                connect: () => {
                    if (socket) return; // Already connected or connecting

                    clearTimeout(reconnectTimer);
                    _updateStatus('Connecting...', 'connecting');
                    const wsUrl = `ws://${window.location.hostname}:${WS_PORT}`;
                     _logEvent({ type: 'info', message: `Attempting to connect to ${wsUrl}` });

                    try {
                        socket = new WebSocket(wsUrl);
                        socket.onopen = _handleOpen;
                        socket.onclose = _handleClose;
                        socket.onerror = _handleError;
                        socket.onmessage = _handleMessage;
                    } catch (e) {
                        _handleError(e); // Treat connection errors like WebSocket errors
                    }
                },

                disconnect: () => {
                    if (!socket) return;
                    clearTimeout(reconnectTimer);
                    reconnectAttempts = MAX_RECONNECT_ATTEMPTS; // Prevent auto-reconnect on manual disconnect
                    socket.close();
                    _logEvent({ type: 'info', message: 'Manual disconnect initiated.' });
                },

                startDuel: () => {
                    // Use the existing API endpoint
                    fetch('/start-duel', { method: 'POST' })
                        .then(response => response.json())
                        .then(data => {
                            _logEvent({ type: 'info', message: `Duel request sent: ${data.message || JSON.stringify(data)}` });
                            // Server should broadcast 'battle_info' if successful
                        })
                        .catch(error => {
                            _logEvent({ type: 'error', message: `Error starting duel: ${error.message}` });
                        });
                },

                init: () => {
                    _initArena();
                    // Setup button listeners
                    elements.connectBtn.addEventListener('click', publicMethods.connect);
                    elements.disconnectBtn.addEventListener('click', publicMethods.disconnect);
                    elements.startDuelBtn.addEventListener('click', publicMethods.startDuel);

                    // Attempt auto-connect on load
                    publicMethods.connect();
                }
            };

            return publicMethods;
        })();

        // --- Initialize the Client ---
        document.addEventListener('DOMContentLoaded', DuelClient.init);

    </script>

</body>
</html> 